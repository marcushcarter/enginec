#pragma once

// ==============================
// Shaders
// ==============================

static const char* BE_DefaultSpriteVert = "#version 460 core\n"
"layout (location = 0) in vec2 aPos;\n"
"layout (location = 1) in vec2 aTex;\n"
"out vec2 texCoord;\n"
"uniform mat4 camMatrix;\n"
"uniform mat4 model;\n"
"void main()\n"
"{\n"
"    gl_Position = camMatrix * model * vec4(aPos, 0.0, 1.0);\n"
"    texCoord = aTex;\n"
"}\n";

static const char* BE_DefaultSpriteFrag = "#version 460 core\n"
"in vec2 texCoord;\n"
"out vec4 FragColor;\n"
"uniform sampler2D spriteTexture;\n"
"uniform vec3 spriteColor;\n"
"void main()\n"
"{\n"
"    vec4 texColor = texture(spriteTexture, texCoord);\n"
"    FragColor = vec4(spriteColor, 1.0) * texColor;\n"
"    if(FragColor.a < 0.1)\n"
"        discard;\n"
"}\n";


static const char* BE_DefaultColorFrag = "#version 460 core\n"
"out vec4 FragColor;\n"
"uniform vec3 color;\n"
"void main() {\n"
"    FragColor = vec4(color, 1.0);\n"
"}\n";

static const char* BE_DefaultDepthVert = "#version 460 core\n"
"layout (location = 0) in vec3 aPos;\n"
"uniform mat4 lightSpaceMatrix;\n"
"uniform mat4 model;\n"
"void main() {\n"
"    gl_Position = lightSpaceMatrix * model * vec4(aPos, 1.0);\n"
"}\n";

static const char* BE_Default3DVert = "#version 460 core\n"
"\n"
"layout (location = 0) in vec3 aPos;\n"
"layout (location = 1) in vec3 aNormal;\n"
"layout (location = 2) in vec3 aColor;\n"
"layout (location = 3) in vec2 aTex;\n"
"\n"
"out vec3 color;\n"
"out vec2 texCoord;\n"
"out vec3 Normal;\n"
"out vec3 crntPos;\n"
"\n"
"uniform mat4 model;\n"
"uniform mat4 camMatrix;\n"
"\n"
"void main() \n"
"{\n"
"    crntPos = vec3(model * vec4(aPos, 1.0f));\n"
"    gl_Position = camMatrix * vec4(crntPos, 1.0f);\n"
"    Normal = aNormal;\n"
"    color = aColor;\n"
"    texCoord = aTex;\n"
"}\n";

static const char* BE_Default3DFrag = "#version 460 core\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 crntPos;\n"
"in vec3 Normal;\n"
"in vec3 color;\n"
"in vec2 texCoord;\n"
"\n"
"uniform sampler2D diffuse0;\n"
"uniform sampler2D specular0;\n"
"uniform vec3 camPos;\n"
"uniform float ambient;\n"
"uniform int sampleRadius;\n"
"\n"
"struct DirectLight {\n"
"    vec3 direction;\n"
"    vec4 color;\n"
"    float specular;\n"
"    mat4 lightSpaceMatrix;\n"
"};\n"
"\n"
"struct PointLight {\n"
"    vec3 position;\n"
"    vec4 color;\n"
"    float a;\n"
"    float b;\n"
"    float specular;\n"
"    mat4 lightSpaceMatrix;\n"
"};\n"
"\n"
"struct SpotLight {\n"
"    vec3 position;\n"
"    vec3 direction;\n"
"    vec4 color;\n"
"    float innerCone;\n"
"    float outerCone;\n"
"    float specular;\n"
"    mat4 lightSpaceMatrix;\n"
"};\n"
"\n"
"uniform int numDirects;\n"
"uniform DirectLight directlights[10];\n"
"uniform sampler2DArray directShadowMapArray;\n"
"\n"
"uniform int numPoints;\n"
"uniform PointLight pointlights[10];\n"
"uniform sampler2DArray pointShadowMapArray;\n"
"\n"
"uniform int numSpots;\n"
"uniform SpotLight spotlights[10];\n"
"uniform sampler2DArray spotShadowMapArray;\n"
"\n"
"vec3 calcDirectLight(DirectLight light, vec3 normal, vec3 viewDirection, int index) {\n"
"    vec3 lightDirection = normalize(-light.direction);\n"
"    float diffuse = max(dot(normal, lightDirection), 0.0f);\n"
"    float specular = 0.0f;\n"
"    if (diffuse != 0.0f) {\n"
"        float specularLight = light.specular;\n"
"        vec3 halfwayVec = normalize(viewDirection + lightDirection);\n"
"        float specAmount = pow(max(dot(normal, halfwayVec), 0.0f), 16);\n"
"        specular = specAmount * specularLight;\n"
"    };\n"
"    vec4 fragPosLight = light.lightSpaceMatrix * vec4(crntPos, 1.0);\n"
"    float shadow = 0.0f;\n"
"    vec3 lightCoords = fragPosLight.xyz / fragPosLight.w;\n"
"    if(lightCoords.z <= 1.0f) {\n"
"        lightCoords = (lightCoords + 1.0f) / 2.0f;\n"
"        float closestDepth = texture(directShadowMapArray, vec3(lightCoords.xy, index)).r;\n"
"        float currentDepth = lightCoords.z;\n"
"        float bias = max(0.002f * (1.0f - dot(normal, lightDirection)), 0.00002f);\n"
"        vec2 pixelSize = 1.0 / vec2(textureSize(directShadowMapArray, index).xy);\n"
"        for (int y = -sampleRadius; y <= sampleRadius; y++) {\n"
"            for (int x = -sampleRadius; x <= sampleRadius; x++) {\n"
"                closestDepth = texture(directShadowMapArray, vec3(lightCoords.xy + vec2(x, y) * pixelSize, index)).r;\n"
"                if (currentDepth > closestDepth + bias) shadow += 1.0f;\n"
"            }\n"
"        }\n"
"        shadow /= pow((sampleRadius * 2. + 1.), 2);\n"
"    }\n"
"    return (texture(diffuse0, texCoord) * diffuse * (1.0f - shadow) + texture(specular0, texCoord).r * specular * (1.0f - shadow)) * light.color;\n"
"}\n"
"\n"
"vec3 calcPointLight(PointLight light, vec3 normal, vec3 viewDirection, int index) {\n"
"    float dist = length(light.position - crntPos);\n"
"    float inten = 1.0f / (light.a * dist * dist + light.b * dist + 1.0f);\n"
"    vec3 lightDirection = normalize(light.position - crntPos);\n"
"    float diffuse = max(dot(normal, lightDirection), 0.0f);\n"
"    float specular = 0.0f;\n"
"    if (diffuse != 0.0f) {\n"
"        float specularLight = light.specular;\n"
"        vec3 halfwayVec = normalize(viewDirection + lightDirection);\n"
"        float specAmount = pow(max(dot(normal, halfwayVec), 0.0f), 16);\n"
"        specular = specAmount * specularLight;\n"
"    };\n"
"    return (texture(diffuse0, texCoord) * (diffuse * inten) + texture(specular0, texCoord).r * specular * inten) * light.color;\n"
"}\n"
"\n"
"vec3 calcSpotLight(SpotLight light, vec3 normal, vec3 viewDirection, int index) {\n"
"    vec3 lightDirection = normalize(light.position - crntPos);\n"
"    float diffuse = max(dot(normal, lightDirection), 0.0f);\n"
"    float specular = 0.0f;\n"
"    if (diffuse != 0.0f) {\n"
"        float specularLight = light.specular;\n"
"        vec3 halfwayVec = normalize(viewDirection + lightDirection);\n"
"        float specAmount = pow(max(dot(normal, halfwayVec), 0.0f), 8);\n"
"        specular = specAmount * specularLight;\n"
"    };\n"
"    float angle = dot(normalize(-light.direction), lightDirection);\n"
"    float inten = clamp((angle - light.outerCone) / (light.outerCone - light.innerCone), 0.0f, 1.0f);\n"
"    vec4 fragPosLight = light.lightSpaceMatrix * vec4(crntPos, 1.0);\n"
"    float shadow = 0.0f;\n"
"    vec3 lightCoords = fragPosLight.xyz / fragPosLight.w;\n"
"    if(lightCoords.z <= 1.0f) {\n"
"        lightCoords = (lightCoords + 1.0f) / 2.0f;\n"
"        float closestDepth = texture(spotShadowMapArray, vec3(lightCoords.xy, index)).r;\n"
"        float currentDepth = lightCoords.z;\n"
"        float bias = max(0.005f * (1.0f - dot(normal, lightDirection)), 0.002f);\n"
"        vec2 pixelSize = 1.0 / vec2(textureSize(spotShadowMapArray, index).xy);\n"
"        for (int y = -sampleRadius; y <= sampleRadius; y++) {\n"
"            for (int x = -sampleRadius; x <= sampleRadius; x++) {\n"
"                closestDepth = texture(spotShadowMapArray, vec3(lightCoords.xy + vec2(x, y) * pixelSize, index)).r;\n"
"                if (currentDepth > closestDepth + bias) shadow += 1.0f;\n"
"            }\n"
"        }\n"
"        shadow /= pow((sampleRadius * 2. + 1.), 2);\n"
"    }\n"
"    return (texture(diffuse0, texCoord) * (diffuse * inten) + texture(specular0, texCoord).r * specular * inten) * light.color;\n"
"}\n"
"\n"
"float near = 0.1f;\n"
"float far = 100.0f;\n"
"\n"
"float linearizeDepth(float depth) {\n"
"    return (2.0 * near * far) / (far + near - (depth * 2.0 - 1.0) * (far - near));\n"
"}\n"
"\n"
"float logisticDepth(float depth) {\n"
"    float steepness = 0.5f;\n"
"    float offset = 5.0f;\n"
"    float zVal = linearizeDepth(depth);\n"
"    return (1 / (1 + exp(-steepness * (zVal - offset))));\n"
"}\n"
"\n"
"void main() {\n"
"    vec3 normal = normalize(Normal);\n"
"    vec3 viewDir = normalize(camPos - crntPos);\n"
"    vec3 result = texture(diffuse0, texCoord).rgb * ambient;\n"
"    for (int i = 0; i < numDirects; i++) result += calcDirectLight(directlights[i], normal, viewDir, i);\n"
"    for (int i = 0; i < numPoints; i++) result += calcPointLight(pointlights[i], normal, viewDir, i);\n"
"    for (int i = 0; i < numSpots; i++) result += calcSpotLight(spotlights[i], normal, viewDir, i);\n"
"    FragColor = vec4(result, 1.0);\n"
"}\n";

// ==============================
// Meshes
// ==============================

static const char* BE_DefaultCubeOBJ =
"# Blender 4.4.0\n"
"# www.blender.org\n"
"o Cube\n"
"v 1.000000 1.000000 -1.000000\n"
"v 1.000000 -1.000000 -1.000000\n"
"v 1.000000 1.000000 1.000000\n"
"v 1.000000 -1.000000 1.000000\n"
"v -1.000000 1.000000 -1.000000\n"
"v -1.000000 -1.000000 -1.000000\n"
"v -1.000000 1.000000 1.000000\n"
"v -1.000000 -1.000000 1.000000\n"
"vn -0.0000 1.0000 -0.0000\n"
"vn -0.0000 -0.0000 1.0000\n"
"vn -1.0000 -0.0000 -0.0000\n"
"vn -0.0000 -1.0000 -0.0000\n"
"vn 1.0000 -0.0000 -0.0000\n"
"vn -0.0000 -0.0000 -1.0000\n"
"vt 0.625000 0.500000\n"
"vt 0.875000 0.500000\n"
"vt 0.875000 0.750000\n"
"vt 0.625000 0.750000\n"
"vt 0.375000 0.750000\n"
"vt 0.625000 1.000000\n"
"vt 0.375000 1.000000\n"
"vt 0.375000 0.000000\n"
"vt 0.625000 0.000000\n"
"vt 0.625000 0.250000\n"
"vt 0.375000 0.250000\n"
"vt 0.125000 0.500000\n"
"vt 0.375000 0.500000\n"
"vt 0.125000 0.750000\n"
"s 0\n"
"f 1/1/1 5/2/1 7/3/1 3/4/1\n"
"f 4/5/2 3/4/2 7/6/2 8/7/2\n"
"f 8/8/3 7/9/3 5/10/3 6/11/3\n"
"f 6/12/4 2/13/4 4/5/4 8/14/4\n"
"f 2/13/5 1/1/5 3/4/5 4/5/5\n"
"f 6/11/6 5/10/6 1/1/6 2/13/6\n";

static const char* BE_DefaultCameraOBJ =
"# Blender 4.4.0\n"
"# www.blender.org\n"
"o Plane\n"
"v 0.000000 1.103553 -2.000000\n"
"v 0.353553 0.750000 -2.000000\n"
"v -0.353553 0.750000 -2.000000\n"
"v -0.707107 0.707107 -2.000000\n"
"v 0.707107 0.707107 -2.000000\n"
"v 0.707107 -0.707107 -2.000000\n"
"v -0.707107 -0.707107 -2.000000\n"
"v 0.000000 -0.000000 0.000000\n"
"vn -0.0000 -0.0000 -1.0000\n"
"vn -0.0000 0.9428 0.3333\n"
"vn 0.9428 -0.0000 0.3333\n"
"vn -0.0000 -0.9428 0.3333\n"
"vn -0.9428 -0.0000 0.3333\n"
"vt 0.000000 0.000000\n"
"vt 0.250000 0.490000\n"
"vt 0.250000 0.250000\n"
"vt 0.490000 0.250000\n"
"vt 0.250000 0.010000\n"
"vt 0.750000 0.490000\n"
"vt 0.990000 0.250000\n"
"vt 0.750000 0.010000\n"
"vt 0.510000 0.250000\n"
"vt 0.010000 0.250000\n"
"s 0\n"
"f 1/1/1 2/1/1 3/1/1\n"
"s 1\n"
"f 4/2/2 8/3/2 5/4/2\n"
"f 5/4/3 8/3/3 6/5/3\n"
"f 4/6/1 5/7/1 6/8/1 7/9/1\n"
"f 6/5/4 8/3/4 7/10/4\n"
"f 7/10/5 8/3/5 4/2/5\n";
