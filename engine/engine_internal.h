/*

    OpenGL loader generated by glad 0.1.36 on Fri Aug  8 16:44:07 2025.

    Language/Generator: C/C++
    Specification: gl
    APIs: gl=4.6
    Profile: core
    Extensions:
        GL_ARB_bindless_texture
    Loader: True
    Local files: False
    Omit khrplatform: False
    Reproducible: False

    Commandline:
        --profile="core" --api="gl=4.6" --generator="c" --spec="gl" --extensions="GL_ARB_bindless_texture"
    Online:
        https://glad.dav1d.de/#profile=core&language=c&specification=gl&loader=on&api=gl%3D4.6&extensions=GL_ARB_bindless_texture
*/


#ifndef ENGINE_H
#define ENGINE_H

#include <engine/glad/glad.h>
#include <engine/GLFW/glfw3.h>
#include <engine/cglm/cglm.h>
#include <engine/stb_image/stb_image.h>
#include <engine/stb_image/stb_image_resize.h>
#include <engine/stb_image/stb_truetype.h>
#include <engine/AL/al.h>
#include <engine/AL/alc.h>
#include <engine/dr_wav/dr_wav.h>
#include <engine/fmod/fmod.h>
#include <time.h>

void BE_MatrixMakeModel(vec3 translation, vec3 rotation, vec3 scale, mat4 dest);
void BE_MatrixMakeBillboard(vec3 position, mat4 view, vec3 scale, mat4 dest);
void BE_OritentationToEuler(vec3 orientation, vec3 outEuler);
void BE_Vec3RotateAxis(vec3 in, vec3 axis, float angle_rad, vec3 out);

#define FPS_HISTORY_COUNT 20

typedef struct {
    clock_t previousTime;
    clock_t currentTime;
    float dt;

    int frameCount;
    int frameCountFPS;

    float fpsTimer;
    float fps;
    float ms;

    float fpsHistory[FPS_HISTORY_COUNT];
    int fpsHistoryIndex;
    int fpsHistoryCount;

} BE_FrameStats;

float BE_UpdateFrameTimeInfo(BE_FrameStats* info);

#define MAX_JOYSTICKS GLFW_JOYSTICK_16+1

/**
 * AXES
 * 0 - LS X
 * 1 - LS Y
 * 2 - RS X
 * 3 - RS Y
 * 4 - LT
 * 5 - RT
 * 
 * BUTTONS
 * 0 - A
 * 1 - B
 * 2 - X
 * 3 - Y
 * 4 - LB
 * 5 - RB
 * 6 - BACK
 * 7 - START
 * 8 - LS
 * 9 - RS
 * 10 - D UP
 * 11 - D RIGHT
 * 12 - D DOWN
 * 13 - D LEFT
 * 14 - 
 * 15 - 
 * 
 * HATS (BITS)
 * 0000 - CENTERED
 * 1000 - UP
 * 0100 - RIGHT
 * 0010 - DOWN
 * 0001 - LEFT
 * 
 */
typedef struct {
    int id;  // like GLFW_JOYSTICK_1
    int present;
    
    const float* axes;
    
    const unsigned char* buttons;
    unsigned char lbuttons[16]; // last-frame buttons

    const unsigned char* hats;
    const char* name;

    int axisCount;
    int buttonCount;
    int hatCount;

    float deadzone;
} BE_Joystick;

void BE_JoystickUpdate(BE_Joystick* joystick);
int BE_JoystickIsPressed(BE_Joystick* js, int button);
int BE_JoystickIsReleased(BE_Joystick* js, int button);
int BE_JoystickIsHeld(BE_Joystick* js, int button);
float BE_JoystickGetAxis(BE_Joystick* js, int axis);

typedef struct {
    vec3 position;
    vec3 normal;
    vec3 color;
    vec2 texUV;
} BE_Vertex;

typedef struct {
    BE_Vertex* data;
    size_t size;
    size_t capacity;
} BE_VertexVector;

void BE_VertexVectorInit(BE_VertexVector* vec);
void BE_VertexVectorPush(BE_VertexVector* vec, BE_Vertex value);
void BE_VertexVectorFree(BE_VertexVector* vec);
void BE_VertexVectorCopy(BE_Vertex* vertices, size_t count, BE_VertexVector* outVec);

typedef struct {
    GLuint ID;
} BE_VAO;

BE_VAO BE_VAOInit();
BE_VAO BE_VAOInitQuad();
BE_VAO BE_VAOInitSprite();
BE_VAO BE_VAOInitBillboardQuad();
void BE_VAOBind(BE_VAO* vao);
void BE_VAODrawQuad(BE_VAO* vao);
void BE_VAOUnbind();
void BE_VAODelete(BE_VAO* vao);

typedef struct {
    GLuint ID;
} BE_VBO;

BE_VBO BE_VBOInitFromData(GLfloat* vertices, GLsizeiptr size);
BE_VBO BE_VBOInitFromVector(BE_VertexVector* vertices);
void BE_VBOBind(BE_VBO* vbo);
void BE_VBOUnbind();
void BE_VBODelete(BE_VBO* vbo);
void BE_LinkVertexAttribToVBO(BE_VBO* vbo, GLuint layout, GLuint numComponents, GLenum type, GLsizeiptr stride, void* offset);

typedef struct {
    GLuint* data;
    size_t size;
    size_t capacity;
} BE_GLuintVector;

void BE_GLuintVectorInit(BE_GLuintVector* vec);
void BE_GLuintVectorPush(BE_GLuintVector* vec, GLuint value);
void BE_GLuintVectorFree(BE_GLuintVector* vec);
void BE_GLuintVectorCopy(GLuint* data, size_t count, BE_GLuintVector* outVec);

typedef struct {
    GLuint ID;
} BE_EBO;

BE_EBO BE_EBOInitFromData(GLuint* indices, GLsizeiptr size);
BE_EBO BE_EBOInitFromVector(BE_GLuintVector* indices);
void BE_EBOBind(BE_EBO* ebo);
void BE_EBOUnbind();
void BE_EBODelete(BE_EBO* ebo);

typedef struct {
    GLuint ID;
} BE_Shader;

char* BE_GetFileContents(const char* filename);
void BE_ShaderGetCompileErrors(unsigned int shader, const char* type);
BE_Shader BE_ShaderInit(const char* vertexFile, const char* fragmentFile, const char* geometryFile, const char* computeFile);
void BE_ShaderActivate(BE_Shader* shader);
void BE_ShaderDelete(BE_Shader* shader);

typedef struct {
    GLuint fbo;
    GLuint texture;
    GLuint rbo;
    BE_VAO vao;
    BE_VBO vbo;
    int width, height;
} BE_FBO;

BE_FBO BE_FBOInit(int width, int height);
void BE_FBOResize(BE_FBO* fbo, int newWidth, int newHeight);
BE_FBO BE_FBOInitShadowMap(int width, int height, float clampColor[4]);
void BE_FBOBind(BE_FBO* fb);
void BE_FBOBindTexture(BE_FBO* fb, BE_Shader* shader);
void BE_FBOUnbind();
void BE_FBODelete(BE_FBO* fb);

typedef struct {
    GLuint ID;
    char* type;
    GLuint unit;
} BE_Texture;

typedef struct {
    BE_Texture* data;
    size_t size;
    size_t capacity;
} BE_TextureVector;

BE_Texture BE_TextureInit(const char* imageFile, const char* texType, GLenum slot);
void BE_TextureSetUniformUnit(BE_Shader* shader, const char* uniform, GLuint unit);
void BE_TextureBind(BE_Texture* texture);
void BE_TextureUnbind();
void BE_TextureDelete(BE_Texture* texture);

void BE_TextureVectorInit(BE_TextureVector* vec);
void BE_TextureVectorPush(BE_TextureVector* vec, BE_Texture value);
void BE_TextureVectorFree(BE_TextureVector* vec);
void BE_TextureVectorCopy(BE_Texture* textures, size_t count, BE_TextureVector* outVec);

typedef struct {
    int width, height;
    float zoom, fov;
    float nearPlane, farPlane;
    vec3 position, direction, Up;
    mat4 projPersp, projOrtho;
    mat4 viewMatrix;
} BE_Camera;

typedef struct {
    BE_Camera* data;
    size_t size;
    size_t capacity;
} BE_CameraVector;

BE_Camera BE_CameraInit(int width, int height, float fov, float nearPlane, float farPlane, vec3 position, vec3 direction);
void BE_CameraInputs(BE_Camera* camera, GLFWwindow* window, BE_Joystick* js, float dt);
void BE_CameraMatrixUploadPersp(BE_Camera* camera, BE_Shader* shader, const char* uniform);
void BE_CameraMatrixUploadOrtho(BE_Camera* camera, BE_Shader* shader, const char* uniform);
void BE_CameraMatrixUploadCustom(BE_Shader* shader, const char* uniform, vec3 position, mat4 matrix);

void BE_CameraVectorInit(BE_CameraVector* vec);
void BE_CameraVectorPush(BE_CameraVector* vec, BE_Camera value);
void BE_CameraVectorFree(BE_CameraVector* vec);
void BE_CameraVectorCopy(BE_Camera* lights, size_t count, BE_CameraVector* outVec);

void BE_CameraVectorUpdateMatrix(BE_CameraVector* vec, int width, int height);

typedef struct {
    BE_VertexVector vertices;
    BE_GLuintVector indices;
    BE_TextureVector textures;
    BE_VAO vao;
} BE_Mesh;

BE_Mesh BE_MeshInitFromVertex(BE_VertexVector vertices, BE_GLuintVector indices, BE_TextureVector textures);
BE_Mesh BE_MeshInitFromData(const char** texbuffer, int texcount, BE_Vertex* vertices, int vertcount, GLuint* indices, int indcount);
void BE_MeshDraw(BE_Mesh* mesh, BE_Shader* shader);
void BE_MeshDrawBillboard(BE_Mesh* mesh, BE_Shader* shader, BE_Texture* texture);

int BE_FindOrAddVertex(BE_Vertex* vertices, int* verticesCount, BE_Vertex v);
void BE_ReplacePathSuffix(const char* path, const char* newsuffix, char* dest, int destsize);
int BE_CountFaceVertices(const char* line);
BE_Mesh BE_LoadOBJToMesh(const char* obj_path);
const char** BE_LoadMTLTextures(const char* mtl_path, int* outCount);

void BE_CameraVectorDraw(BE_CameraVector* vec, BE_Mesh* mesh, BE_Shader* shader, BE_Camera* selected);

typedef struct {
    vec3 position;
    vec3 rotation;
    vec3 scale;
} BE_Transform;

typedef struct {
    BE_Mesh* mesh;
    BE_Transform transform;
} BE_Model;

typedef struct {
    BE_Model* data;
    size_t size;
    size_t capacity;
} BE_ModelVector;

BE_Transform BE_TransformInit(vec3 position, vec3 rotation, vec3 scale);

BE_Model BE_ModelInit(BE_Mesh* mesh, BE_Transform transform);

void BE_ModelVectorInit(BE_ModelVector* vec);
void BE_ModelVectorPush(BE_ModelVector* vec, BE_Model value);
void BE_ModelVectorFree(BE_ModelVector* vec);
void BE_ModelVectorCopy(BE_Model* models, size_t count, BE_ModelVector* outVec);

void BE_ModelVectorDraw(BE_ModelVector* vec, BE_Shader* shader);

#define DIRECT_LIGHT_DIST 50

typedef struct {
    GLuint fbo;
    GLuint depthTextureArray;
    int width, height;
    int layers;
} BE_ShadowMapFBO;

typedef enum {
    LIGHT_DIRECT,
    LIGHT_POINT,
    LIGHT_SPOT
} BE_LightType;

typedef struct {
    int type;

    vec3 position;
    vec3 direction;
    vec4 color;
    mat4 lightSpaceMatrix;
    float specular;
    
    // pointlight
    float a;
    float b;
    
    // spotlight
    float innerCone;
    float outerCone;
} BE_Light;

typedef struct {
    BE_Light* data;
    size_t size;
    size_t capacity;
    
    float ambient;
    BE_ShadowMapFBO directShadowFBO;
    BE_ShadowMapFBO pointShadowFBO;
    BE_ShadowMapFBO spotShadowFBO;

    int shadowsDirty;
} BE_LightVector;

BE_ShadowMapFBO BE_ShadowMapFBOInit(int width, int height, int layers);
void BE_ShadowMapFBOBindLayer(BE_ShadowMapFBO* smfbo, int layer);
void BE_ShadowMapFBODelete(BE_ShadowMapFBO* smfbo);

typedef void (*ShadowRenderFunc)(BE_Shader* shader);

BE_Light BE_LightInit(int type, vec3 position, vec3 direction, vec4 color, float specular, float a, float b, float innerCone, float outerCone);

void BE_LightVectorInit(BE_LightVector* vec);
void BE_LightVectorPush(BE_LightVector* vec, BE_Light value);
void BE_LightVectorFree(BE_LightVector* vec);
void BE_LightVectorCopy(BE_Light* lights, size_t count, BE_LightVector* outVec);

void BE_LightVectorUpdateMatrix(BE_LightVector* vec);
void BE_LightVectorUpdateMaps(BE_LightVector* vec, BE_Shader* shadowShader, ShadowRenderFunc renderFunc, bool enabled);
void BE_LightVectorUpdateMultiMaps(BE_LightVector* vec, BE_ModelVector* models, BE_Shader* shadowShader, bool enabled);
void BE_LightVectorUpload(BE_LightVector* vec, BE_Shader* shader);
void BE_LightVectorDraw(BE_LightVector* vec, BE_Mesh* mesh, BE_Shader* shader);

// typedef struct {
//     float u0, v0, u1, v1;
//     int width, height;
//     int bearingX, bearingY;
//     int advance;
// } BE_Glyph;

// typedef struct {
//     GLuint atlasTex;
//     int atlasWidth;
//     int atlasHeight;

//     BE_Glyph* glyphs;
//     int glyphCount;

//     int lineHeight;
// } BE_Font;

// typedef struct {
//     BE_Font* font;
//     char* text;
//     vec3 position;
//     vec4 color;
//     float scale;

//     GLuint vao, vbo;
//     int quadCount;
//     bool isDynamic;

//     bool dirty;
// } BE_Text;

// typedef struct {
//     BE_Text* data;
//     size_t size;
//     size_t capacity;
// } BE_TextVector;

// // FOnt Load

// BE_Font BE_FontLoad(const char* ttf_path, int pixelSize);
// BE_Text BE_TextInit(const char* text, BE_Font* font, vec3 position, float scale, vec4 color, bool dynamic);
// void BE_TextUpdate(BE_Text* t, const char* newText);

// void BE_TextRender(BE_Text* t, GLuint shaderProgram, mat4 proj);

// void BE_TextVectorInit(BE_TextVector* vec);
// void BE_TextVectorPush(BE_TextVector* vec, BE_Text value);
// void BE_TextVectorFree(BE_TextVector* vec);
// void BE_TextVectorCopy(BE_Text* texts, size_t count, BE_TextVector* outVec);

typedef struct {
    vec3 position;
    vec2 scale;
    float rotation;
    vec3 color;
    BE_Texture* texture;
} BE_Sprite;

typedef struct {
    BE_Sprite* data;
    size_t size;
    size_t capacity;

    BE_VAO vao;
} BE_SpriteVector;

BE_Sprite BE_SpriteInit(vec3 position, vec2 scale, float rotation, vec3 color, BE_Texture* texture);

void BE_SpriteVectorInit(BE_SpriteVector* vec);
void BE_SpriteVectorPush(BE_SpriteVector* vec, BE_Sprite value);
void BE_SpriteVectorFree(BE_SpriteVector* vec);
void BE_SpriteVectorCopy(BE_Sprite* sprites, size_t count, BE_SpriteVector* outVec);

void BE_SpriteVectorDraw(BE_SpriteVector* vec, BE_Shader* shader);

// #define MAX_PARTICLES (10000)
// #define WORKGROUP_SIZE (250)

// typedef struct {
//     vec4 pos_life;
//     vec4 vel_age;
//     vec4 col_size;
// } BE_ParticleGPU;

// typedef struct {
//     BE_Shader computeShader;
//     BE_Shader renderShader;
//     GLuint ssbo;
//     BE_VAO vao;
//     BE_Texture sprite;
//     int particleCount;
// } BE_GPUParticles;

// BE_GPUParticles BE_ParticlesInit(const char* vertexFile, const char* fragmentFile, const char* computeFile, const char* imageFile);
// void BE_ParticlesUpdate(BE_GPUParticles* ps, float dt, uint32_t frame);
// void BE_ParticlesDraw(BE_GPUParticles* ps, mat4 view, mat4 proj, int additive);

typedef struct {
    ALuint soundID;
    char* name;
    char* path;
    int channels;
} BE_Sound;

typedef struct {
    BE_Sound* data;
    size_t size;
    size_t capacity;
} BE_SoundVector;

BE_Sound BE_LoadWav(const char* path, const char* name);

void BE_SoundVectorInit(BE_SoundVector* vec);
void BE_SoundVectorPush(BE_SoundVector* vec, BE_Sound value);
void BE_SoundVectorFree(BE_SoundVector* vec);
void BE_SoundVectorCopy(BE_Sound* sounds, size_t count, BE_SoundVector* outVec);

typedef struct {
    ALuint sourceID;
    BE_Sound* sound;
    vec3 position;
    float gain;
    float pitch;
    bool looping;
    bool spatial;
} BE_SoundSource;

typedef struct {
    BE_SoundSource* data;
    size_t size;
    size_t capacity;
} BE_SoundSourceVector;

BE_SoundSource BE_SoundSourceInit(BE_Sound* sound, vec3 position, bool spatial);

void BE_SoundSourcePlay(BE_SoundSource* source);
void BE_SoundSourceStop(BE_SoundSource* source);
void BE_SoundSourceSetPosition(BE_SoundSource* source, vec3 position);
void BE_SoundSourceSetGain(BE_SoundSource* source, float gain);
void BE_SoundSourceSetSound(BE_SoundSource* source, BE_Sound* newSound);

void BE_SoundSourceVectorInit(BE_SoundSourceVector* vec);
void BE_SoundSourceVectorPush(BE_SoundSourceVector* vec, BE_SoundSource value);
void BE_SoundSourceVectorFree(BE_SoundSourceVector* vec);
void BE_SoundSourceVectorCopy(BE_SoundSource* sources, size_t count, BE_SoundSourceVector* outVec);

void BE_SoundSourceVectorDraw(BE_SoundSourceVector* vec, BE_Mesh* mesh, BE_Shader* shader);

typedef struct {
    ALCdevice* device;
    ALCcontext* context;
} BE_SoundSystem;

void BE_SoundSystemUpdateListener(BE_Camera* cam);
void BE_SoundSystemInit(BE_SoundSystem* system);

typedef struct {
    BE_ModelVector models;
    BE_LightVector lights;
    BE_CameraVector cameras;
    BE_SpriteVector sprites;
    BE_SoundSystem soundsys;
    BE_SoundVector sounds;
    BE_SoundSourceVector sources;
} BE_Scene;

typedef struct {
    BE_Scene* data;
    size_t size;
    size_t capacity;
} BE_SceneVector;

BE_Scene BE_SceneInit();

void BE_SceneVectorInit(BE_SceneVector* vec);
void BE_SceneVectorPush(BE_SceneVector* vec, BE_Scene value);
void BE_SceneVectorFree(BE_SceneVector* vec);
void BE_SceneVectorCopy(BE_Scene* scenes, size_t count, BE_SceneVector* outVec);

#endif