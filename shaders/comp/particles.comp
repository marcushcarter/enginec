// particles.comp
#version 430
layout(local_size_x = 256) in;

struct Particle {
    vec4 pos_life;  // xyz pos, w = life remaining
    vec4 vel_age;   // xyz vel, w = age
    vec4 col_size;  // rgb color, w = size (pixels)
};

layout(std430, binding = 0) buffer Particles {
    Particle p[];
};

uniform float u_dt;            // seconds
uniform vec3  u_gravity;       // e.g., vec3(0, -9.81, 0)
uniform uint  u_frame;         // frame counter for varied spawning
uniform uint  u_spawnBudget;   // max spawns per dispatch (throttle)

uint rng(inout uint state) {
    // PCG-ish hash; fine for particles
    state = state * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28) + 4)) ^ state) * 277803737u;
    return (word >> 22) ^ word;
}

float rand01(inout uint s) { return float(rng(s)) * (1.0/4294967296.0); }

void spawn(uint id, inout uint s) {
    // Example: spawn around origin in a sphere, upward velocity, random color/size
    vec3 pos = (rand01(s) * 2.0 - 1.0) * normalize(vec3(rand01(s), rand01(s), rand01(s)));
    pos *= 0.5; // radius

    vec3 vel = vec3( (rand01(s)-0.5)*2.0,
                      rand01(s)*3.5 + 2.0,         // upward bias
                      (rand01(s)-0.5)*2.0 );

    float life = mix(1.0, 3.0, rand01(s));
    float size = mix(8.0, 24.0, rand01(s));

    vec3 color = mix(vec3(1.0, 0.7, 0.2), vec3(1.0, 0.9, 0.5), rand01(s)); // fire-ish

    p[id].pos_life = vec4(pos, life);
    p[id].vel_age  = vec4(vel, 0.0);
    p[id].col_size = vec4(color, size);
}

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id >= p.length()) return;

    Particle q = p[id];
    float life = q.pos_life.w;
    float age  = q.vel_age.w;

    // Dead? Try to respawn (probabilistic throttle)
    if (life <= 0.0) {
        // Stochastically limit spawns per frame (cheap way without atomics)
        uint state = id * 9781u + u_frame * 6271u;
        if (rand01(state) < float(u_spawnBudget) / float(p.length())) {
            spawn(id, state);
            return;
        } else {
            // stay dead
            return;
        }
    }

    // Integrate
    vec3 pos = q.pos_life.xyz;
    vec3 vel = q.vel_age.xyz;

    vel += u_gravity * u_dt;
    pos += vel * u_dt;

    age  += u_dt;
    life -= u_dt;

    q.pos_life = vec4(pos, life);
    q.vel_age  = vec4(vel, age);

    // Optional fade: encode in color alpha (weâ€™ll derive alpha in FS)
    p[id] = q;
}
